#library "c" libc
#library "libCHTTP.dylib" chttp

print :: (string, ..any) -> void #foreign libc "printf"

// C socket datatypes and constants
in_addr :: struct {
    s_addr : u32
}

sockaddr_in :: struct {
    sin_len : u8
    sa_family_t : u8
    sin_port_t : u16
    sin_addr: u32
    sin_zero: [8]i8
}

AF_INET : u8 = 2
SOCK_STREAM : u32 = 1

// C sockets
socket :: (u32, u32, u32) -> i32 #foreign libc "socket"
bind :: (u32, *sockaddr_in, u64) -> i32 #foreign libc "bind"
listen :: (u32, i32) -> i32 #foreign libc "listen"
accept :: (u32, *sockaddr_in, *u64) -> u32 #foreign libc "accept" 
write :: (u32, string, i32) -> i64 #foreign libc "write"
read :: (u32, *i8, i64) -> i64 #foreign libc "read"
htons :: (u16) -> u16 #foreign libc "htons"
close :: (u32) -> u32 #foreign libc "close"
exit :: (u32) -> void #foreign libc "exit"

errno : i32 #foreign libc "errno"

error :: (message: string) -> void {
    print("error (%d): %s\n", errno, message)
    exit(1)
}

PORT : u16 = 8080

main :: () -> void {
    sockfd := socket(u32(AF_INET), SOCK_STREAM, 0)    
    if sockfd < 0 error("opening socket")

    defer close(u32(sockfd))

    port := htons(PORT)

    zero: [8]i8

    self := sockaddr_in {
        0, AF_INET, port, 0, zero
    }   

    result := bind(u32(sockfd), &self, 16) 
    if result != 0 error("Binding socket")

    result = listen(u32(sockfd), 5)
    if result != 0 error("Listening")

    client := sockaddr_in {
        0, AF_INET, port, 0, zero
    }
    
    clientSize: u64 = 16

    newsockfd := accept(u32(sockfd), &client, &clientSize)
    
    if newsockfd < 0 error("Accepting client connection")

    buffer : [255]i8
    running := true
    for running {
        n := read(newsockfd, (*i8)(buffer), 255)

        if n == 0 {
            print("Connection closed\n")
            running = false
        } else if n < 0 {
            error("Attempting read")
            running = false
        }

        write(newsockfd, "server: Hey!\n", 13)
    }
}
