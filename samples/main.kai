#library "c" libc

print :: (string, ..any) -> void #foreign libc "printf"
length :: (string) -> u64 #foreign libc "strlen"

// Program entry point
main :: () -> void {

    //arr: [1][1]int = {{1}}


    section :: () -> void {
        for i := 0; i < 3; i += 1 {
            print("\n")
        }
    }

    { // Pointers and numbers

        val := 8
        p := &val

        <p = 123

        print("val: %d, p: %d\n", val, p)
    }

    section()

    { // Pointers and strings

        str := "Hey\n"
        p := &str

        print(<p)

        <p = "I got changed\n"

        print(<p)
    }

    section()

    { // NullablePointers

        name := "Brett"
        len := length(name)

        strPtr : *u8 = name

        print("The string is `%s`\n", name)
        print("The string is `%d` bytes long.\n", len)
        print("The first byte is `%c`\n", <strPtr)

        // Won't compile, you cannot assign `nil` to a pointer.

        // strPtr = nil

        nullableStrPtr := (^u8)(strPtr)
        print("The nullable pointer is `0x%08x`\n", nullableStrPtr)

        nullableStrPtr = nil
        print("The nullable pointer is `0x%08x`\n", nullableStrPtr)
    }

    section()

    { // Nested procedure

        foo :: (n: int) -> void {
            n += 5
            print("foo printing %d\n", n)
            n = 4
            print("foo printing %d\n", n)
        }

        n := 5
        foo(n)

        print("main printing %d\n", n)
    }

    section()

    { // Arrays

        x : [3]int = { 5, 6, 4 }


        for i := 0; i < 3; i += 1 {
            print("x[%d] = %d\n", i, x[i])
        }
    }

    section()

    { // Multiple returns

        addFive :: (x: int, y: int) -> int, int {
            return x + 5, y + 5
        }

        origin :: () -> int, int {
            return 0, 0
        }

        x1, x2 := origin()
        print("x1: %d, x2: %d\n", x1, x2)

        x1, x2 = addFive(x1, x2)
        print("x1: %d, x2: %d\n", x1, x2)

        p1, p2 := &x1, &x2
        print("p1: %d, p2: %d\n", <p1, <p2)

        <p1, <p2 = addFive(<p1, <p2)
        print("p1: %d, p2: %d\n", <p1, <p2)
    }

    section()

    { // Double dereference and simple precedence
        print("%d\n", 2 + 4 * 10)

        x := 5
        y := &x

        print("y: %d\n", <y)

        z := &y
        print("z: %d\n", <<z)

        <<z = 19
        print("z: %d\n", <<z)
    }

    section()

    { // casting between sizes and types
        x : i8  = -128
        y : u16 = u16(x)
        z : u8  = u8(256)

        i : f32 = f32(x)
        j : f64 = f64(z)
        k : f64 = f64(1 + 2 + 3)

        print("x: %hhd, y: %hu, z: %hhu\n", x, y, z)
        print("i: %.2f, j: %.2f, k: %.2f\n", f64(i), j, k)
        // NOTE(vdka): There is a bug here due to some C strangeness
        // C emits an fpext instruction for floating point aguments to get them to double
        // Without float's being passed as doubles to printf, it prints the 0 value.
    }

    section()

    { // defer keyword

        deferDemo :: () -> void {
            defer print("I was defered first!\n")
            defer print("I was defered last!\n")
            print("I was not defered\n")
        }

        deferDemo()
    }

    section()

    { // Ternary

        print("0 ? 1 : 0 -> %d\n", 0 ? 1 : 0)
        print("1 ? 1 : 0 -> %d\n", 1 ? 1 : 0)

        print("0 ? 1 ? 2 : 3 : 0 -> %d\n", 0 ? 1 ? 2 : 3 : 0)
        print("1 ? 1 ? 2 : 3 : 0 -> %d\n", 1 ? 1 ? 2 : 3 : 0)
    }
}

