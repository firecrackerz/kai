#library "c" libc

//printf :: (string, ..any) -> void #foreign libc "printf"
length :: (string) -> u64 #foreign libc "strlen"

Color :: struct {
    name: string
    r, g, b: u8
}

Person :: struct {
    name: string
    age: int

    favoriteColor: Color
}

// Program entry point
main :: () -> void {
    section :: () -> void {
        for i := 0; i < 3; i += 1 {
            printf("\n")
        }
    }

    { // Exponents
      val := 2837.5e-2
      printf("val: %f\n", val)
    }

    section()

    { // Pointers and numbers

        val1 := 1
        val2 := 2
        p1 := &val1
        p2 := &val2

        <p1 *= 2

        printf("val1: %d, p1: 0x%08x, p2: 0x%08x\n", val1, p1, p2)
    }

    section()

    { // Pointers and strings

        str := "Hey\n"
        p := &str

        printf(<p)

        <p = "I got changed\n"

        printf(<p)
    }

    section()

    { // NullablePointers

        name := "Brett"
        len := length(name)

        strPtr : *u8 = name

        printf("The string is `%s`\n", name)
        printf("The string is `%d` bytes long.\n", len)
        printf("The first byte is `%c`\n", <strPtr)
    }

    section()

    { // Nested procedure

        foo :: (n: int) -> void {
            n += 5
            printf("foo printfing %d\n", n)
            n = 4
            printf("foo printfing %d\n", n)
        }

        n := 5
        foo(n)

        printf("main printfing %d\n", n)
    }

    section()

    { // Arrays

        x := [3]int{ 5, 6, 4 }


        for i := 0; i < 3; i += 1 {
            printf("x[%d] = %d\n", i, x[i])
        }
    }

    section()

    { // Multiple returns

        addFive :: (x: int, y: int) -> int, int {
            return x + 5, y + 5
        }

        origin :: () -> int, int {
            return 0, 0
        }

        x1, x2 := origin()
        printf("x1: %d, x2: %d\n", x1, x2)

        x1, x2 = addFive(x1, x2)
        printf("x1: %d, x2: %d\n", x1, x2)

        p1, p2 := &x1, &x2
        printf("p1: %d, p2: %d\n", <p1, <p2)

        <p1, <p2 = addFive(<p1, <p2)
        printf("p1: %d, p2: %d\n", <p1, <p2)
    }

    section()

    { // Double dereference and simple precedence
        printf("%d\n", 2 + 4 * 10)

        x := 5
        y := &x

        printf("y: %d\n", <y)

        z := &y
        printf("z: %d\n", <<z)

        <<z = 19
        printf("z: %d\n", <<z)
    }

    section()

    {
        printf("0 ? 1 : 0 -> %d\n", 0 ? 1 : 0)
        printf("1 ? 1 : 0 -> %d\n", 1 ? 1 : 0)

        printf("0 ? 1 ? 2 : 3 : 0 -> %d\n", 0 ? 1 ? 2 : 3 : 0)
        printf("1 ? 1 ? 2 : 3 : 0 -> %d\n", 1 ? 1 ? 2 : 3 : 0)
    }

    section()

    {
        buf := malloc(16)

        for i : u8 = 0; i < 16; i += 1 {
            buf[int(i)] = i
        }

        for i := 0; i < 16; i += 1 {
            printf("%hhx ", buf[i])
        }

        free(buf)
    }

    section()

    {

        printfPerson :: (person: Person) -> void {
            printf("Person{'%s', %d}\n", person.name, person.age)
        }

        // aliasing

        BusinessPerson :: Person

        gary := Person{"Gary", 43}

        printfPerson(gary)

        red := Color{"Red", 0xff, 0, 0}

        bob := Person{"Bob", 21, red}
        bob.age = 42

        printfPerson(bob)

        bob.favoriteColor = Color{"Blue", 0, 0, 0xff}

        printf("%s is %d years old\n", bob.name, bob.age)
        printf(
            "%s's favorite Color is %s (#%02hhx%02hhx%02hhx)\n",
            bob.name,
            bob.favoriteColor.name,
            bob.favoriteColor.r,
            bob.favoriteColor.g,
            bob.favoriteColor.b
        )

        /*
        colors := [2]Color{red, blue}

        for i := 0; i < 2; i += 1 {
            color := colors[i]
            name := colors[i].name
            printf("%s has the hex code #%02hhx%02hhx%02hhx\n", name, color.r, color.g, color.b)
        }
        */
    }
}

