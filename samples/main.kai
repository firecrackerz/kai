#library "c" libc

print :: (string, ..any) -> void #foreign libc "printf"
length :: (string) -> u64 #foreign libc "strlen"

Color :: struct {
    name: string
    r, g, b: u8
}

Person :: struct {
    name: string
    age: int

    favoriteColor: Color
}

// Program entry point
main :: () -> void {
    section :: () -> void {
        for i := 0; i < 3; i += 1 {
            print("\n")
        }
    }

    { // Exponents
      val := 2837.5e-2
      print("val: %f\n", val)
    }

    section()

    { // Pointers and numbers

        val := 8
        p := &val

        <p = 123

        print("val: %d, p: %d\n", val, p)
    }

    section()

    { // Pointers and strings

        str := "Hey\n"
        p := &str

        print(<p)

        <p = "I got changed\n"

        print(<p)
    }

    section()

    { // NullablePointers

        name := "Brett"
        len := length(name)

        strPtr : *u8 = name

        print("The string is `%s`\n", name)
        print("The string is `%d` bytes long.\n", len)
        print("The first byte is `%c`\n", <strPtr)

        // Won't compile, you cannot assign `nil` to a pointer.

        // strPtr = nil

        nullableStrPtr := (^u8)(strPtr)
        print("The nullable pointer is `0x%08x`\n", nullableStrPtr)

        nullableStrPtr = nil
        print("The nullable pointer is `0x%08x`\n", nullableStrPtr)
    }

    section()

    { // Nested procedure

        foo :: (n: int) -> void {
            n += 5
            print("foo printing %d\n", n)
            n = 4
            print("foo printing %d\n", n)
        }

        n := 5
        foo(n)

        print("main printing %d\n", n)
    }

    section()

    { // Arrays

        x : [3]int = { 5, 6, 4 }


        for i := 0; i < 3; i += 1 {
            print("x[%d] = %d\n", i, x[i])
        }
    }

    section()

    { // Multiple returns

        addFive :: (x: int, y: int) -> int, int {
            return x + 5, y + 5
        }

        origin :: () -> int, int {
            return 0, 0
        }

        x1, x2 := origin()
        print("x1: %d, x2: %d\n", x1, x2)

        x1, x2 = addFive(x1, x2)
        print("x1: %d, x2: %d\n", x1, x2)

        p1, p2 := &x1, &x2
        print("p1: %d, p2: %d\n", <p1, <p2)

        <p1, <p2 = addFive(<p1, <p2)
        print("p1: %d, p2: %d\n", <p1, <p2)
    }

    section()

    { // Double dereference and simple precedence
        print("%d\n", 2 + 4 * 10)

        x := 5
        y := &x

        print("y: %d\n", <y)

        z := &y
        print("z: %d\n", <<z)

        <<z = 19
        print("z: %d\n", <<z)
    }

    section()

    {
        print("0 ? 1 : 0 -> %d\n", 0 ? 1 : 0)
        print("1 ? 1 : 0 -> %d\n", 1 ? 1 : 0)

        print("0 ? 1 ? 2 : 3 : 0 -> %d\n", 0 ? 1 ? 2 : 3 : 0)
        print("1 ? 1 ? 2 : 3 : 0 -> %d\n", 1 ? 1 ? 2 : 3 : 0)
    }

    section()

    {
        buf := malloc(16)

        for i : u8 = 0; i < 16; i += 1 {
            <buf[int(i)] = i
        }

        for i := 0; i < 16; i += 1 {
            printf("%hhx ", <buf[i])
        }

        free(buf)
    }

    section()

/*
    {
        red: Color = {"Red", 255, 0, 0}

        bob: Person = {"Bob", 21, red}
        bob.age = 42

        print("%s is %d years old.\nHis favorite color is %s (#%02hx%02hx%02hx)\n", bob.name, bob.age, bob.favoriteColor.name, bob.favoriteColor.r, bob.favoriteColor.g, bob.favoriteColor.b)

        blue: Color = {"Blue", 0, 255, 0}

        /*
        colors: [2]Color = {red, blue}

        for i := 0; i < 2; i += 1 {
            color := colors[i]
            name := colors[i].name
            print("%s has the hex code %2.x%2.x%2.x\n", name, color.r, color.g, color.b)
        }
        */
    }
*/
}
