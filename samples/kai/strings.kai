len :: (str: string) -> u64 {
    return <(*u64)(&str[-16])
}

cap :: (str: string) -> u64 {
    return <(*u64)(&str[-8])
}

setCap :: (str: string, capacity: u64) -> void {
    <(*u64)(&str[-8]) = capacity
}

setLen :: (str: string, length: u64) -> void {
    <(*u64)(&str[-16]) = length
}

rawLen :: (str: rawptr) -> u64 {
    length := 0

    for i := 0; str[i] != 0; i += 1 {
        length += 1
    }

    return length
}

hasSuffix :: (str: string, suffix: string) -> bool {
    strLen := len(str)
    suffixLen := len(suffix)

    if strLen < suffixLen return false

    strEnd := strLen - 1
    suffixEnd := suffixLen - 1

    for i := 0; i < suffixLen; i += 1 {
        if str[int(strEnd) - i] != suffix[int(suffixEnd) - i] return false 
    }

    return true
}

hasRawSuffix :: (str: string, suffix: rawptr, suffixLen: u64) -> bool {
    return true
}

rawHasRawSuffix :: (str: rawptr, strLen: u64, suffix: rawptr, suffixLen: u64) -> bool {
    return true
}

expandTo :: (str: string, capacity: u64) -> string {
    length := len(str)
    
    ptr := realloc(rawptr(&str[-16]), capacity)
    str = string(&ptr[16])

    setCap(str, capacity)
    setLen(str, length)
    return str
}

makeWithCap :: (capacity: u64) -> string {
    buff := malloc(capacity + 17)

    strPtr := string(&buff[16])

    setLen(strPtr, 0)
    setCap(strPtr, capacity)

    return strPtr
}

makeFromRaw :: (ptr: rawptr, len: u64) -> string {
    buff := malloc(len + 17) // len, cap and \0
    buff[int(len + 16)] = 0

    <(*u64)(&buff[0]) = len // len
    <(*u64)(&buff[8]) = len // cap

    return (string)(memcpy((rawptr)(&buff[16]), ptr, len))
}

appendRaw :: (str: string, ptr: rawptr, ptrLen: u64) -> string {
    oldLen := len(str)
    newLen := oldLen + ptrLen
    if newLen > cap(str) {
        str = expandTo(str, newLen * 2)
    }

    memcpy(rawptr(&str[int(oldLen)]), ptr, ptrLen)
    setLen(str, newLen)

    return str
}

expand :: (str: string) -> string {
    length := len(str)
    newCap := cap(str) * 2

    str = string(realloc(rawptr(&str[-16]), newCap))
    setCap(str, newCap)
    setLen(str, length)
    return str
}


destroy :: (str: string) -> void {
    free(rawptr(&str[-16]))
}
