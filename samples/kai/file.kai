#import "libc.kai"
#import "strings.kai"

FileStatus :: enum {
    ok, notFound
}

readWholeFile :: (path: string) -> string, FileStatus {
    file := libc.fopen(path, "r")
    if file == nil return "", FileStatus.notFound

    defer libc.fclose(file)

    result := strings.makeWithCap(1024) // pre-allocate result with 1kb buffer

    BUFFER_SIZE := 4096
    buffer := malloc(BUFFER_SIZE)
    defer free(buffer)

    for true {
        count := libc.fread(buffer, 1, BUFFER_SIZE, file)
        result = strings.appendRaw(result, buffer, u64(count))
        if count < BUFFER_SIZE break
    }    

    return result, FileStatus.ok
}

SourceLocation :: struct {
    file : string
    line: u64
    column: u64
}

SourceRange :: struct {
    lowerBound : SourceLocation
    upperBound : SourceLocation
}

describeSourceLocation :: (location: SourceLocation) -> string {
    // TODO(Brett): string split
    return ""
}

cmpSourceLocation :: (lhs: SourceLocation, rhs: SourceLocation) -> bool {
    return lhs.file == rhs.file && lhs.line == rhs.line && lhs.column == rhs.column
}

main :: (argc: i32, argv: **u8) -> i32 {
    if argc < 2 {
        printf("Invalid arguments. Please supply file\n")
        return 1
    }

    file, status := readWholeFile(string(argv[1]))
    { using FileStatus
        switch status {
        case ok: {
            printf("The file is %llu bytes long (cap: %llu)\n", strings.len(file), strings.cap(file))
            printf("%s\n", file)
        } 
        case notFound: {
            printf("Could not open %s\n", argv[1])
            return 2
        }

        default: {
            printf("Unknown error while trying to read file\n")
            return 3
        }
        }
    }    

    return 0
}
