
#test "int to ptr cast" {
    x : u64    = 13
    y : rawptr = cast(rawptr) x
    z : u64    = cast(u64) x
    assert(x == 13)
}

#test "integer literal to pointer cast" {
    x := cast(*u16) 0xB8000
    y := cast(u64)  x
    assert(y == 0xB8000)
}

#test "pointer reinterpret const float to int" {
    float: f64 = 5.99999999999994648725e-01
    float_ptr := &float
    int_ptr := cast(*i32) float_ptr
    int_val := <int_ptr
    assert(int_val == 858993411)
}

#test "pointer assign with nil literal" {
    x: *u8 = nil
    y: rawptr = nil
    assert(x == nil)
    assert(y == nil)
    assert(cast(u64) x == 0)
    assert(cast(u64) y == 0)
}

#test "explicit cast from float number literal to integer" {
    x := cast(i64) 6.28
    y := cast(i64) 1e4
    assert(x == 6)
    assert(y == 10000)
}

#test "enum auto incrementing" {
    Foo :: enum(u32) {
        v0
        v1
        v78 :: 78
        v79
        v20 :: 20
        v21
    }

    assert(cast(u32) Foo.v0  ==  0)
    assert(cast(u32) Foo.v1  ==  1)
    assert(cast(u32) Foo.v78 == 78)
    assert(cast(u32) Foo.v79 == 79)
    assert(cast(u32) Foo.v20 == 20)
    assert(cast(u32) Foo.v21 == 21)
}

#test "enum #flags auto incrementing" {
    Foo :: enum(u32) #flags {
        v1   // 1 << 0
        v2   // 1 << 1
        v4   // 1 << 2
        v8   // 1 << 3
        v64  :: 1 << 6
        v128 // 1 << 7
        v16  :: 1 << 4
        v32  // 1 << 5
    }

    assert(cast(u32) Foo.v1   == 1)
    assert(cast(u32) Foo.v2   == 2)
    assert(cast(u32) Foo.v4   == 4)
    assert(cast(u32) Foo.v8   == 8)
    assert(cast(u32) Foo.v16  == 16)
    assert(cast(u32) Foo.v32  == 32)
    assert(cast(u32) Foo.v64  == 64)
    assert(cast(u32) Foo.v128 == 128)
}

#test "explicit cast from enum to backing type" {
    Reg :: enum(u32) { r0; r1; r2; r3; r4; r5; r6; r7 }

    assert(cast(u32) Reg.r0 == 0)
    assert(cast(u32) Reg.r5 == 5)
}
