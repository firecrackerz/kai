
#import kai("posix")
#import builtin("types")
#import builtin("platform")

Foo :: struct {
    a, b, c: i64
}

//width :: fn(type: types.Type) -> i64 {
//    switch type.Tag {
//    case 0b001: // ty.Boolean:
//        return autocast (bitcast(types.Boolean)type).Width
//    case 0b010: // ty.Integer:
//        return autocast (bitcast(types.Integer)type).Width
//    case 0b011: // ty.FloatingPoint:
//        return autocast (bitcast(types.Float)type).Width
//    case 0b100: // ty.Anyy:
//        return 64
//    case:
//        return compoundWidth(<type.Compound)
//    }
//}
//
//compoundWidth :: fn(type: types.Compound) -> i64 {
//    switch type.Tag {
//    case 0b000: // ty.Named:
//        return 0
//    case 0b001: // ty.Function:
//        return 64
//    case 0b010: // ty.Array:
//        return 1
//    case 0b011: // ty.Vector:
//        return 1
//    case 0b100: // ty.Struct:
//        return 1
//    case 0b101: // ty.Union:
//        return 1
//    case 0b110: // ty.Enum:
//        return 1
//    case 0b111: // ty.Pointer:
//        return 8123
//    case:
//       return -1
//    }
//}

main :: fn() -> i32 {

    ty1 := types.TypeOf(*i64)
    ty2 := cast(*types.Pointer)(ty1.Compound)

    //w := width(ty1)

    //posix.printf("%d\n".raw, w)
    posix.printf("%p\n".raw, ty1)
    posix.printf("%p\n".raw, <ty2)
    //posix.printf("%s\n".raw, platform.OSTriple.raw)
    //posix.printf("%d\n".raw, platform.PointerWidth)
    //posix.printf("%d\n".raw, platform.IsBigEndian)
    return 5
}

