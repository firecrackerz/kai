
#library "libc"
#import "glfw.kai"

#foreign libc {
    printf :: (fmt: *u8, args: #cvargs ..any) -> i32

    exit :: (exitcode: i32) -> void
}


panic :: fn(msg: string) -> void {
    printf(msg.raw)
    exit(1)
}

// OpenGL constants, only the ones we need
FALSE                :: 0x0000
TRIANGLE_STRIP       :: 0x0005
DEPTH_BUFFER_BIT     : u32 : 0x0100
COLOR_BUFFER_BIT     : u32 : 0x4000
DEPTH_TEST           :: 0x0B71
UNSIGNED_SHORT       :: 0x1403
FLOAT                :: 0x1406
ARRAY_BUFFER         :: 0x8892
ELEMENT_ARRAY_BUFFER :: 0x8893
STATIC_DRAW          :: 0x88E4
VERTEX_SHADER        :: 0x8B31
FRAGMENT_SHADER      :: 0x8B30

// For more, look up http://docs.gl, where you can sort by version
Enable:                   (cap: u32) -> void

ClearColor:               (r, g, b, a: f32) -> void
Clear:                    (mask: u32) -> void

GenVertexArrays:          (count: i32, buffers: *u32) -> void
BindVertexArray:          (buffer: u32) -> void
DeleteVertexArrays:       (n: i32, arrays: *u32) -> void

GenBuffers:               (count: i32, buffers: *u32) -> void
BindBuffer:               (target: i32, buffer: u32) -> void
BufferData:               (target: i32, size: i32, data: rawptr, usage: i32) -> void
DeleteBuffers:            (n: i32, buffers: *u32) -> void

EnableVertexAttribArray:  (index: u32) -> void
VertexAttribPointer:      (index: u32, size, type: i32, normalized: i32, stride: u32, pointer: rawptr) -> void

CreateShader:             (shaderType: i32) -> u32
ShaderSource:             (shader: u32, count: u32, str: **u8, length: *i32) -> void
CompileShader:            (shader: u32) -> void
DeleteShader:             (shader: u32) -> void

CreateProgram:            () -> u32
AttachShader:             (program, shader: u32) -> void
LinkProgram:              (program: u32) -> void
DeleteProgram:            (program: u32) -> void

UseProgram:               (program: u32) -> void
GetUniformLocation:       (program: u32, name: *u8) -> i32
Uniform1f:                (loc: i32, v0: f32) -> void
Uniform2f:                (loc: i32, v0, v1: f32) -> void
UniformMatrix4fv:         (loc: i32, count: u32, transpose: i32, value: *f32) -> void

DrawElements:             (mode: i32, count: u32, type: i32, indices: rawptr) -> void

getGlFunctions :: fn(_getProcAddress: rawptr) -> void {
    getProcAddress := cast((*u8) -> rawptr) _getProcAddress

    Enable             = cast((u32) -> void) getProcAddress("glEnable\x00".raw)

    ClearColor         = cast((f32, f32, f32, f32) -> void) getProcAddress("glClearColor\x00".raw)
    Clear              = cast((u32) -> void) getProcAddress("glClear\x00".raw)

    GenBuffers         = cast((i32, *u32) -> void) getProcAddress("glGenBuffers\x00".raw)
    GenVertexArrays    = cast((i32, *u32) -> void) getProcAddress("glGenVertexArrays\x00".raw)
    DeleteVertexArrays = cast((i32, *u32) -> void) getProcAddress("glDeleteVertexArrays\x00".raw)

    BindBuffer         = cast((i32, u32) -> void) getProcAddress("glBindBuffer\x00".raw)
    BindVertexArray    = cast((u32) -> void) getProcAddress("glBindVertexArray\x00".raw)
    BufferData         = cast((i32, i32, rawptr, i32) -> void) getProcAddress("glBufferData\x00".raw)
    DeleteBuffers      = cast((i32, *u32) -> void) getProcAddress("glDeleteBuffers\x00".raw)

    EnableVertexAttribArray = cast((u32) -> void) getProcAddress("glEnableVertexAttribArray\x00".raw)
    VertexAttribPointer     = cast((u32, i32, i32, i32, u32, rawptr) -> void) getProcAddress("glVertexAttribPointer\x00".raw)

    CreateShader       = cast((i32) -> u32) getProcAddress("glCreateShader\x00".raw)
    ShaderSource       = cast((u32, u32, **u8, *i32) -> void) getProcAddress("glShaderSource\x00".raw)
    CompileShader      = cast((u32) -> void) getProcAddress("glCompileShader\x00".raw)
    DeleteShader       = cast((u32) -> void) getProcAddress("glDeleteShader\x00".raw)

    CreateProgram      = cast(() -> u32) getProcAddress("glCreateProgram\x00".raw)
    AttachShader       = cast((u32, u32) -> void) getProcAddress("glAttachShader\x00".raw)
    LinkProgram        = cast((u32) -> void) getProcAddress("glLinkProgram\x00".raw)
    DeleteProgram      = cast((u32) -> void) getProcAddress("glDeleteProgram\x00".raw)

    UseProgram         = cast((u32) -> void) getProcAddress("glUseProgram\x00".raw)
    GetUniformLocation = cast((u32, *u8) -> i32) getProcAddress("glGetUniformLocation\x00".raw)
    Uniform1f          = cast((i32, f32) -> void) getProcAddress("glUniform1f\x00".raw)
    Uniform2f          = cast((i32, f32, f32) -> void) getProcAddress("glUniform2f\x00".raw)
    UniformMatrix4fv   = cast((i32, u32, i32, *f32) -> void) getProcAddress("glUniformMatrix4fv\x00".raw)

    DrawElements       = cast((i32, u32, i32, rawptr) -> void) getProcAddress("glDrawElements\x00".raw)
}

//glfwErrorCallback :: fn(error: i32, desc: *u8) -> void {
//    printf("Error code %d:\n\t%s\n", error, desc)
//}

initGlfw :: fn() -> *glfw.Window, bool {
    //glfw.SetErrorCallback(&glfwErrorCallback)

    if glfw.Init() == 0 {
        return nil, false
    }

    glfw.WindowHint(glfw.SAMPLES, 4)
    glfw.WindowHint(glfw.CONTEXT_VERSION_MAJOR, 3)
    glfw.WindowHint(glfw.CONTEXT_VERSION_MINOR, 3)
    glfw.WindowHint(glfw.OPENGL_PROFILE, glfw.OPENGL_CORE_PROFILE)
    glfw.WindowHint(glfw.OPENGL_FORWARD_COMPAT, 1)

    window := glfw.CreateWindow(1280, 720, "Kai GLFW example\x00".raw, nil, nil)
    if window == nil {
        panic("Asdfklasjdf\x00")
        return nil, false
    }

    glfw.MakeContextCurrent(window)

    return window, true
}

loadShaders :: fn() -> u32 {
    vertex_shader_source := "
        #version 330 core

        layout(location = 0) in vec3 vertexPosition;

        uniform float time;

        out vec3 pos;

        void main() {
            gl_Position = vec4(vertexPosition, 1.0);
            pos = vertexPosition;
        }\x00
    "
    fragment_shader_source := "
        #version 330 core

        in vec3 pos;
        in vec2 resolution;
        uniform float time;
        out vec4 color;

        void main() {
            vec2 uv = pos.xy / resolution.xy;
            color = vec4(uv, 0.5 + 0.5 * sin(time), 1.0);
        }\x00
    "

    vertex_shader_length := cast(i32) vertex_shader_source.len
    fragment_shader_length := cast(i32) fragment_shader_source.len

    vertex_shader_id := CreateShader(VERTEX_SHADER)
    fragment_shader_id := CreateShader(FRAGMENT_SHADER)

    ShaderSource(vertex_shader_id, 1, &vertex_shader_source.raw, &vertex_shader_length)
    ShaderSource(fragment_shader_id, 1, &fragment_shader_source.raw, &fragment_shader_length)

    CompileShader(vertex_shader_id)
    CompileShader(fragment_shader_id)

    program := CreateProgram()
    AttachShader(program, vertex_shader_id)
    AttachShader(program, fragment_shader_id)
    LinkProgram(program)

    DeleteShader(vertex_shader_id)
    DeleteShader(fragment_shader_id)

    return program
}

createBuffers :: fn() -> u32, u32, u32 {
    vao: u32
    GenVertexArrays(1, &vao)
    BindVertexArray(vao)

    // a 2x2x2 cube, using triangle strips and indices
    cubeVertices := [..]f32 {
        -1.0, -1.0,  1.0,
         1.0, -1.0,  1.0,
        -1.0,  1.0,  1.0,
         1.0,  1.0,  1.0,
        -1.0, -1.0, -1.0,
         1.0, -1.0, -1.0,
        -1.0,  1.0, -1.0,
         1.0,  1.0, -1.0,
    }

    cubeIndices := [..]u16{
        // TRIANGLE_STRIP, 14 indices = 12 triangles
        0, 1, 2, 3, 7, 1, 5, 4, 7, 6, 2, 4, 0, 1,
    }

    vbo: u32
    GenBuffers(1, &vbo)
    BindBuffer(ARRAY_BUFFER, vbo)
    BufferData(ARRAY_BUFFER, 96, cast(rawptr) &cubeVertices[0], STATIC_DRAW)

    EnableVertexAttribArray(0)
    VertexAttribPointer(0, 3, FLOAT, FALSE, 0, nil)

    ebo: u32
    GenBuffers(1, &ebo)
    BindBuffer(ELEMENT_ARRAY_BUFFER, ebo)
    BufferData(ELEMENT_ARRAY_BUFFER, 28, cast(rawptr) &cubeIndices[0], STATIC_DRAW)

    return vao, vbo, ebo
}

main :: fn () -> void {

    printf("Hello!\n\x00".raw)
    printf("HERE\n\x00".raw)

    window, success := initGlfw()
    if !success
        panic("Error with window creation!\n\x00")

    getGlFunctions(cast(rawptr) glfw.GetProcAddress)

    program := loadShaders()

    vao, vbo, ebo := createBuffers()

    // timings
    tPrev := glfw.GetTime()
    frame := 0

    res := [2]f32{1280, 720}

    Enable(DEPTH_TEST);
    ClearColor(0.2, 0.3, 0.4, 1.0);
    for glfw.WindowShouldClose(window) == glfw.FALSE {

        tNow := glfw.GetTime()
        dt := cast(f32) (tNow - tPrev)
        tPrev = tNow

        glfw.PollEvents()

        //
        // Drawing
        Clear(COLOR_BUFFER_BIT | DEPTH_BUFFER_BIT);

        UseProgram(program)
        Uniform1f(GetUniformLocation(program, "time\x00".raw), cast(f32) glfw.GetTime())
        Uniform2f(GetUniformLocation(program, "resolution\x00".raw), 1280, 720)

        BindVertexArray(vao)
        DrawElements(TRIANGLE_STRIP, 14, UNSIGNED_SHORT, nil)

        glfw.SwapBuffers(window)
    }
    glfw.Terminate()
    printf("Exiting!\n\x00".raw)
}

